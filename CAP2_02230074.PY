#Importing Necessary Modules
import random #We create unique account numbers using 'random', which is used to generate random numbers.
import string #There are constants provided by 'string', such as string.digits, which has all digit characters ('0' to '9').

#account class
class Account: #A fundamental class for encapsulating a bank account is the Account class.

    def __init__(self, account_number, balance=0, account_type="", password=""): #The constructor function __init__ initializes the account with:
        self.account_number = account_number #account_number: An exclusive number assigned to the account.
        self.balance = balance #balance: The account's current balance, which is 0 by default.
        self.account_type = account_type #account_type: The kind of account (business or personal).
        self.password = password #password: The account's password.
        
#methods in account class
    def check_balance(self): #The account's current balance is returned via the check_balance method.
        return self.balance

    def deposit(self, amount): #The deposit method updates the account balance by a certain amount and returns the updated amount.
        self.balance += amount
        return self.balance

    def withdraw(self, amount): #If there are enough money available, the withdraw function takes a certain amount out of the balance; if not, it produces an error message and returns False.
        if amount > self.balance:
            print("Insufficient funds.")
            return False
        else:
            self.balance -= amount
            return True

    def transfer_money(self, recipient_account, amount): #The transfer_money method uses the withdraw and deposit methods to move a certain amount, assuming there are enough funds, to another account. If successful, it returns True; if not, it returns False.
        if amount > self.balance:
            print("Insufficient funds.")
            return False
        else:
            self.withdraw(amount)
            recipient_account.deposit(amount)
            return True

    def delete_account(self, accounts): #The delete_account function modifies the file storage and eliminates the account from the specified list of accounts.
        accounts.remove(self)
        save_accounts_to_file(accounts)
        print(f"Account {self.account_number} deleted successfully.")

#Derived Classes: PersonalAccount and BusinessAccount
class PersonalAccount(Account): #"Personal" is the first account type in PersonalAccount, which derives from Account.
    def __init__(self, account_number, balance=0, password=""):
        super().__init__(account_number, balance, "Personal", password)

class BusinessAccount(Account): #BusinessAccount is an account type that starts with "Business" and inherits from Account.
    def __init__(self, account_number, balance=0, password=""):
        super().__init__(account_number, balance, "Business", password)

#helper functions
def generate_account_number(): #A 10-digit random number is generated by the generate_account_number function and used as the account number.
    return ''.join(random.choices(string.digits, k=10))

def create_account(account_type, initial_deposit=0): #Depending on the account type supplied, create_account produces a new account number, establishes a password, and creates a PersonalAccount or BusinessAccount.
    account_number = generate_account_number()
    password = input("Set a password for your account: ")
    if account_type == "personal":
        return PersonalAccount(account_number, initial_deposit, password)
    elif account_type == "business":
        return BusinessAccount(account_number, initial_deposit, password)

def login(account_number, password): #Login compares the supplied credentials to accounts that are saved, returning the corresponding account if it is discovered.
    accounts = load_accounts_from_file()
    for account in accounts:
        if account.account_number == account_number and account.password == password:
            return account
    return None

def save_accounts_to_file(accounts): #Every account is written to a new line in a file called accounts.txt by the function save_accounts_to_file.
    with open("accounts.txt", "w") as file:
        for account in accounts:
            file.write(f"{account.account_number},{account.balance},{account.account_type},{account.password}\n")

def load_accounts_from_file(): #In order to generate PersonalAccount and BusinessAccount objects and produce a list of accounts, load_accounts_from_file reads account information from the file.
    accounts = []
    try:
        with open("accounts.txt", "r") as file:
            for line in file.readlines():
                account_info = line.strip().split(",")
                account_type = account_info[2]
                if account_type == "Personal":
                    account = PersonalAccount(account_info[0], float(account_info[1]), account_info[3])
                elif account_type == "Business":
                    account = BusinessAccount(account_info[0], float(account_info[1]), account_info[3])
                accounts.append(account)
    except FileNotFoundError:
        pass
    return accounts

def find_account_by_number(account_number, accounts): #In the given list of accounts, find_account_by_number looks for an account with a certain account number.
    for account in accounts:
        if account.account_number == account_number:
            return account
    return None


#Up until the user leaves, the main function manages user interaction in a loop.
#At startup, it loads accounts from the file.
#Users may create, log in, move money between accounts, remove accounts, and log out.
#It receives the necessary inputs for each action, executes the specified procedures, and saves the modified file.

#main function
def main(): 
    accounts = load_accounts_from_file()
    while True:
        action = input("Enter action (create, login, transfer, delete, exit): ").lower()
        if action == "create":
            account_type = input("Enter account type (personal/business): ").lower()
            initial_deposit = float(input("Enter initial deposit: "))
            new_account = create_account(account_type, initial_deposit)
            accounts.append(new_account)
            save_accounts_to_file(accounts)
            print(f"New account {new_account.account_number} created.")
        elif action == "login":
            account_number = input("Enter account number: ")
            password = input("Enter password: ")
            logged_in_account = login(account_number, password)
            if logged_in_account:
                print(f"Logged in to account {logged_in_account.account_number}.")
                # Add menu options for logged-in account
            else:
                print("Invalid credentials.")
        elif action == "transfer":
            sender_account_number = input("Enter sender account number: ")
            receiver_account_number = input("Enter receiver account number: ")
            amount = float(input("Enter transfer amount: "))
            sender_account = find_account_by_number(sender_account_number, accounts)
            receiver_account = find_account_by_number(receiver_account_number, accounts)
            if sender_account and receiver_account:
                if sender_account.transfer_money(receiver_account, amount):
                    save_accounts_to_file(accounts)
                    print("Transfer successful.")
                else:
                    print("Transfer failed.")
            else:
                print("Invalid account numbers.")
        elif action == "delete":
            account_number = input("Enter account number to delete: ")
            password = input("Enter password: ")
            account_to_delete = login(account_number, password)
            if account_to_delete:
                account_to_delete.delete_account(accounts)
            else:
                print("Invalid credentials or account not found.")
        elif action == "exit":
            break
        else:
            print("Unknown command.")

#Execution Entry Point
if __name__ == "__main__": #makes sure that only when the script is run directly—that is, not when it is imported as a module—is main called.
    main()

